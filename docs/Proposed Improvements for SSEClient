# Proposed Improvements for SSEClient

This document outlines potential improvements for the `SSEClient` class (`src/sse-client.ts`) to enhance its performance, reliability, and maintainability.

## Reliability Enhancements

### 1. Maximum Buffer Size

**Issue:**
The `_extractAndProcessEventsFromBuffer` method accumulates data in a `buffer`. If the server sends malformed SSE data (e.g., without `\n\n` event terminators) or extremely large messages without newlines, this buffer could grow indefinitely, potentially leading to high memory usage or an out-of-memory (OOM) error.

**Suggestion:**
Implement a configurable maximum buffer size. If the buffer exceeds this size, the client should:

1. Emit an error (e.g., `DatastarSSEError('SSE buffer exceeded maximum size')`).
2. Abort the current connection (e.g., `this.controller?.abort('buffer_overflow')`).
3. Clear the buffer.
This will trigger a clean reconnection attempt.

**Example Implementation Snippet:**

```typescript
// In SSEClient class
private maxBufferSizeBytes: number; // New property

constructor(options: SSEClientOptions) {
  // ...
  this.maxBufferSizeBytes = options.maxBufferSizeBytes || 1 * 1024 * 1024; // Default to 1MB
}

private _extractAndProcessEventsFromBuffer(buffer: string): string {
  if (buffer.length > this.maxBufferSizeBytes) { // Or use Buffer.byteLength(buffer) for more accuracy
    this.emit('error', new DatastarSSEError('SSE buffer exceeded maximum size. Resetting connection.'));
    this.controller?.abort('buffer_overflow');
    return ''; // Clear the buffer
  }
  // ... rest of the method
}
```

And update `SSEClientOptions` in `src/types.ts`:

```typescript
export interface SSEClientOptions {
  // ... existing options
  maxBufferSizeBytes?: number;
}
```

### 2. Handling Graceful Server-Side Stream Closure

**Issue:**
When the `ReadableStream` in `_processEventStream` reports `done: true`, it signifies the server has gracefully closed the connection. The current `_handleDisconnect(false)` call will still attempt to reconnect.

**Suggestion:**
While reconnection is often desired, providing a more specific event or slightly different handling for a graceful server close could be beneficial.

1. Emit a distinct event (e.g., `close` with a specific reason like `server_disconnected`) when the stream ends gracefully.
2. Only attempt reconnection if `isExplicitlyClosed` is `false`.

**Example Implementation Snippet (`_processEventStream`):**

```typescript
// ...
if (done) {
  if (!this.isExplicitlyClosed) {
    this.emit('close', { 
      intentional: false, 
      reason: 'server_disconnected', 
      willReconnect: true // Indicate that a reconnect attempt will follow
    });
    this._handleDisconnect(false); // Proceed with reconnection logic
  } else {
    // Server closed the stream while we were also trying to close explicitly
    this.emit('close', { 
      intentional: true, 
      reason: 'server_disconnected_during_explicit_close' 
    });
  }
  break;
}
// ...
```

### 3. More Specific Error Parsing in `connect()`

**Issue:**
In the `connect()` method, if `response.json()` fails when parsing an *error* response body (e.g., the error body from the server is not valid JSON), a generic `DatastarSSEError` is thrown, potentially losing the original HTTP status or context.

**Suggestion:**
Improve error handling when parsing the error response body:

1. Attempt to read the error body as text first.
2. If JSON parsing of the text fails, emit a `warning` or a more specific error, but still throw an error based on the HTTP status (e.g., `DatastarAuthenticationError` or `DatastarSSEError`) including the original status and the raw text body if JSON parsing failed.

**Example Implementation Snippet (`connect()` error handling block):**

```typescript
// ...
if (!response.ok) {
  let errorMessage = `SSE connection failed with status: ${response.status}`;
  let errorBodyJson: any = null;
  let errorBodyText: string | null = null;

  try {
    errorBodyText = await response.text(); // Get as text first
    if (errorBodyText) {
      try {
        errorBodyJson = JSON.parse(errorBodyText);
        // errorMessage += ` - ${errorBodyText}`; // Or use structured errorBodyJson
      } catch (jsonParseError: any) {
        this.emit('warning', new DatastarSSEError(`Failed to parse JSON error response body for status ${response.status}: ${jsonParseError.message}. Raw body: ${errorBodyText}`));
      }
    }
    
    const finalErrorMessage = errorBodyJson ? JSON.stringify(errorBodyJson) : errorBodyText;

    if (response.status === 401 || response.status === 403) {
      throw new DatastarAuthenticationError(
        `Authentication error connecting to SSE: ${response.status}${finalErrorMessage ? ` - ${finalErrorMessage}` : ''}`,
        response.status,
        errorBodyJson // Pass parsed JSON or null
      );
    }
    
    throw new DatastarSSEError(
      `SSE connection failed: ${response.status}${finalErrorMessage ? ` - ${finalErrorMessage}` : ''}`, 
      response.status, 
      errorBodyJson
    );
  } catch (e) {
    if (e instanceof DatastarAuthenticationError || e instanceof DatastarSSEError) {
      throw e;
    }
    // Fallback if reading/parsing text itself throws unexpectedly
    throw new DatastarSSEError(errorMessage, response.status); 
  }
}
// ...
```

*(Note: This requires `DatastarSSEError` and `DatastarAuthenticationError` constructors to potentially accept `status` and `body` arguments consistently).*

## Performance Considerations

### 1. String Concatenation for Multi-line Data in `_parseEvent`

**Issue:**
For multi-line `data` fields in SSE events, the current code `event.data = event.data + '\n' + value;` creates new strings in a loop. For very large multi-line data payloads, this could be less performant than using an array and `join()` at the end.

**Suggestion (Minor Optimization):**
For scenarios with extremely large multi-line data, consider accumulating data lines in an array and then joining them. For typical SSE message sizes, the current approach is clear and likely sufficient.

**Example Implementation Snippet (`_parseEvent`):**

```typescript
// In _parseEvent, when initializing 'event'
const event: Partial<SSEEvent> & { dataLines?: string[] } = {
  eventName: 'message',
  // data: '' // No longer initialize data directly
};

// ... inside the loop, for 'data' field:
case 'data':
  if (!event.dataLines) {
    event.dataLines = [];
  }
  event.dataLines.push(value);
  break;

// ... after the loop, before returning the event:
if (event.dataLines) {
  event.data = event.dataLines.join('\n');
  try {
    event.data = JSON.parse(event.data as string);
  } catch (e) { /* Keep as string if not valid JSON */ }
  delete event.dataLines; // Clean up temporary array
  return event as SSEEvent;
} else if (Object.keys(event).length > 1 || event.eventName !== 'message') { 
  // If it's a named event or has an ID, even without data, it's valid
  event.data = ''; // Ensure data field exists
  return event as SSEEvent;
}
return null; // Only return null if it's truly an empty/invalid event
```

### 2. `queueMicrotask` in `_dispatchEvent`

**Context:**
Using `queueMicrotask` ensures that events are emitted asynchronously after the current synchronous code block finishes. This helps maintain event order and can prevent re-entrancy issues.

**Performance:**
It introduces a tiny, often negligible, delay.

**Recommendation:**
**Keep `queueMicrotask`**. The benefits for event ordering and preventing unexpected behavior in event handlers usually outweigh the micro-delay, especially for I/O bound operations like SSE. Only consider removing it if profiling under extreme load demonstrates it as a significant bottleneck and event handlers are guaranteed to be simple and non-blocking.

## General Code Health & Maintainability

### 1. Timer Types

**Issue:**
The current code uses `NodeJS.Timeout` for `reconnectTimer` and `heartbeatTimer`. While Bun aims for Node.js compatibility, using a more generic type can improve portability.

**Suggestion:**
Use `ReturnType<typeof setTimeout>` for timer types. This is a standard TypeScript utility type that correctly infers the return type of `setTimeout` in any JavaScript environment.

**Example:**

```typescript
private reconnectTimer?: ReturnType<typeof setTimeout>;
private heartbeatTimer?: ReturnType<typeof setTimeout>;
```

### 2. Conditional Logging

**Issue:**
`console.log` statements (e.g., `[SSE] ...`) are very useful for debugging during development and testing but can be noisy in production environments or when the SDK is used as a library.

**Suggestion:**
Implement a more flexible logging strategy:

* **Option 1 (Simple):** Add a `debug` or `logLevel` option to `SSEClientOptions`. Only log if the level is appropriate.

    ```typescript
    // In constructor
    this.debugMode = options.debugMode || false;

    // In methods
    if (this.debugMode) {
      console.log('[SSE] Reconnecting...');
    }
    ```

* **Option 2 (Advanced):** Allow a custom logger function to be passed in `SSEClientOptions`. This logger would conform to an interface (e.g., `{ log(message), error(message), warn(message) }`). If no logger is provided, it could default to `console` or no-op.

### 3. Consistent Error Object Structure

**Issue:**
Custom error classes like `DatastarSSEError` and `DatastarAuthenticationError` could benefit from a more consistent structure, especially when including HTTP status codes or response bodies.

**Suggestion:**
Ensure constructors for custom errors consistently accept and store relevant information like `status`, `body`, or `isRetryable`. This makes error handling by the SDK consumer more predictable.

Example for `DatastarSSEError`:

```typescript
// src/types.ts
export class DatastarSSEError extends Error {
  public readonly status?: number;
  public readonly body?: any;

  constructor(message: string, status?: number, body?: any) {
    super(message);
    this.name = 'DatastarSSEError';
    this.status = status;
    this.body = body;
    Object.setPrototypeOf(this, DatastarSSEError.prototype);
  }
}
```

These proposed improvements aim to make the `SSEClient` more robust, easier to debug, and more adaptable to various operational environments. They should be considered and prioritized based on observed behavior and specific project requirements.
